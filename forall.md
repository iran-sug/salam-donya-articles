# in the name of ALLAH

### اسلکالا - Scala

اسکالا یک زبان کامپایلیStatic Type است که روی JVM اجرا می‌شود؛ این زبان ویژگی‌های شی‌گرائی (Object-Orinted) و تابعی (Functional) را در کنار هم ارائه میکند و به همین دلیل ویژگی‌های منحصر به فردی دارد؛ یکی از دلایل دیگر‌ی که باعث مقبولیت و همچنین Productivity این زبان میشود، Syntax منعطف این آن است که اسکالا را به رقیبی جدی برای DSL ها تبدیل کرده است. از همین جهت برخی اسکالا را جمع دو زبان و چارچوب جاوا و  روبی میدانند.

اسکالا پایه‌ای‌ترین عضو چارچوب/بستر  Typesafe است؛ از اهداف این چارچوب همراه شدن با تغییراتی است که روند توسعه نرم‌افزار را متحول می‌کنند. حقیقت این است که نیاز‌ها و شرایط تولید نرم‌افزارها تغییر کرده‌اند؛ امروزه چابکی (Agility) و Productivity در فرایند تولید یک نیاز واقعی است؛ اما در کنار آن، محصول تولید شده نیز باید مقیاس‌پذیر (Scalable) و پاسخگو (Responsive) باشد؛ چارچوب/بستر Typesafe سعی در تولید/پشتیبانی ابزار‌هایی دارد که با معماری Reactive مطابق بوده و همچنین تأثیر مثبتی در Productivity  و Agility فرایند توسعه داشته باشند. از ابزارهای تولید شده در این بستر می‌توان به Akka (معادل Erlang/OTP در فضای JVM است و برای ایجاد برنامه‌های با همروندی (Concurrency) بالا و حتی توزیع‌شده (Distributed) مورد استفاده قرار میگیرد) و PlayFramework (یک چارچوب برای تولید برنامه‌های وب با ساختاری ویژه و سرعت بالا است) اشاره کرد.این بستر توسط شرکتی با هیمن نام (Typesafe) پشتیبانی می‌شود. وجود یک سازمان پشتیبانی برای ابزار‌های متن‌بازی همچون اسکالا ، آکا (Akka) و Play گاهی اوقات باعث دلگرمی استغاده کنندگان از آن چارچوب/بستر می‌شود.

هنر اسکالا ( و چارچوب/بستر Typesafe ) همراه کردن  Productivity زبان‌های Dynamic Type ای همچون Python و Ruby در کنار سرعت و قابلیت اطمینان زبان‌های Static Type ای همچون   C ، Java و Go است. در ادامه‌ی مطلب به تفصیل خصا‌یص زبان اسکالا را بررسی خواهیم کرد.

```
مفهوم Reactive استانداردی است که بر اساس آن برنامه‌های تولید شده باید Scalable و Responsive و Resilient و Event Driven باشند؛ از این بین، دو مفهموم Scalable و Responsive بودن یک نرم‌افزار تولید شده، بیش از دیگر مفاهیم برای مشتری نرم‌افزار قابل درک است؛
مقیاس‌پذیر (Scalable) بودن نرم‌افزار تضمین میکند که اگر برنامه با سخت‌افزاری قوی (مثلاً CPU ای با 16 هسته) اجرا بشود، بتواند از تمام توان سیستم استفاده کند (بدون نیاز به ایجاد تغییر در برنامه)؛ و در شرایط دیگر اگر روی سخت‌افزاری ضعیف‌تر (مثلاً ۲ هسته) اجرا شد، بدون مشکل و افت کیفی قابل اجرا باشد. همچنین اجرای چند نمونه از یک نرم‌افزار ( در یک سرور یا چند سرور ) برای پاسخ‌گویی به نیاز‌های بوجود آمده (مثلاً تعداد Request بالا ) از خصوصیات نرم‌افزار Scalable است.
اما Responsive بودن یک نرم‌افزار، به معنی پاسخگو بودن آن نرم‌افزار، به مصرف‌کننده است. طبق این اساس اگر مصرف‌کننده (کاربرنهایی یا نرم‌افزاردیگری  ) بیش از حد معمول منتظر پاسخ برنامه بماند، برنامه Responsive نیست. این ویژگی با مفهوم soft-real-time همپوشانی دارد.
```

### افسانه‌ها

شروع کردن سخت است و از آن سخت‌تر ادامه دادن... مطلبی را شروع کردم و حالا باید ادامه بدهم... ولی چطور؟ منظورم این است که با چه عنوانی؟... بعد از کمی کلنجار رفتن با فکر بی خواب  و آشفته به اینجا رسیدم‌: «افسانه‌ها»؛ معرفی سازمان و شرکت‌هایی است پیشتر محصولی را به کار بسته‌اند و بررسی نتایجی که کسب کردند،  شاید یکی از بهترین راه‌های معرفی آن محصول باشد ( محصولی که جدید نیست و شما اول کسی نیستید که می‌خواهید از آن استفاده کنید )؛ من هم تصمیم دارم افسانه‌‌ی شرکت‌ها/سازمان‌هایی که این راه را رفته‌اند بازگو کنم؛ عنوان افسانه‌ها هم دور از اصل مطلب دور نیست… قصد ندارم به StartUp موفق twitter و ماجرای مهاجرتش از Ruby به Scala ، یا از ForeSquare و یا حتی LinkedIn و استفاده‌هاش از Scala بپردازم؛ این‌ها شهره‌ی خاص و عام هستند... اما نکته‌ای که در این شرکت‌ها وجود دارد این است که آن‌ها مصرف کننده‌ی فناوری نیستند... آن‌ها فناوری را پیش می‌برند؛ برای نتیجه‌گیری خوب و سازگار با فضای فناوری کشور باید سازمان‌ها و شرکت‌هایی معرفی بشوند که در این زمینه ( تکنولوژی ) مصرف کننده‌اند؛ شرکت‌هایی مثل فروشگاه‌های زنجیره‌ای WalMart.

در سال ۲۰۱۲، شعبه‌ی کانادایی WalMart تصمیم به بازسازی سایت فروش خود گرفت ( WalMart.ca ) و از همین رو با شرکت فناورانه‌ی Nurun وارد مذاکره شد؛ شرکت Nurun یکی از شرکت‌های تولید نرم‌افزار و سرویس‌های نرم‌افزاری است که در زمینه‌ی e-Commerence نیز تجربه دارد. در راه حل ارائه شده توسط شرکت Nurun چارچوب/بستر Typesafe خود‌نمایی میکرد. توسعه‌ی سریعتر با استفاده از Scala و Play تا حداقل ۲ برابر ( نسبت به بستر سابق شرکت WalMart که Java بود )، کاهش هزینه‌های سخت‌افزاری شرکت بین 20 تا 50 درصد و استفاده حداکثری از کتابخانه‌های موجود ( که به زبان جاوا بودند ) از مزایای این انتخاب بود. یکی دیگر از مزایای چارچوب Typesafe و بالطبع زبان Scala امکان Deploy راحتر نرم‌افزار نسبت به Java و JavaEE بود.

گروه فنی خبرگذاری Guardian، هم در بازسازی بستر‌نرم افزاری از Scala و Play انتخاب کردند؛ بستر پیشین این شرکت Spring ، Java و Hibernate بود.از نتایج حاصله‌ی این انتخاب برای گروه فنی Guardian، سرعت در توسعه، Scalable بودن Scala و همین‌طور جذابیت بیشتر این زبان بود.
سرویس Wandoujia یک سایت ( + نرم‌افزار گوشی ) ارائه کننده خدمات سرگرمی به کاربران تلفن‌های همراه در چین است که قریب ۴۰۰ میلیون کاربر دارد. این سرویس با Scala و Akka ایجاد شده و طبق اعلام گروه توسعه‌ی سرویس ( بر اساس benchmark های انجام شده ) انتظار می‌رود به ازائ هر سرور بتوانند به ۱ میلیون اتصال ( Simultaneous Connections ) سرویس بدهند. {منبع: http://typesafe.com/blog/qa-with-caoyuan-deng-akka-at-wandoujia}

شرکت WhitePages هم با بازنویسی بخش‌های اساسی سیستم خود، قریب 90 درصد در منابع سخت افزاری صرفه‌جویی کرد! (پبشتر WhitePages از Ruby و Perl استفاده میکرد). StartUp موفق Coursera نیز یکی دیگر از نمونه‌ای هایی است برای دست یابی به سرعت بالاتر از PHP به Scala مهاجرت کردند.

اگر علاقه‌مند هستید می‌توانید لیستی از نامدارترین شرکت‌هایی که آشکارا از Scala استفاده کردند را در آدرس typesafe.com/company/casestudies ببینید.

نکته: Yammer در سال ۲۰۱۱ اعلام کرد که می‌خواد از Scala به Java مهاجرت کند؛ دیلایل آن‌ها برای این کار پیچیدگی و عدم بلوغ این زبان برنامه‌نویسی است. این نشان‌دهنده‌ی این است که یک ابزار برای همه‌ی کارها و همه‌گروه‌ها مناسب نیست.

### … ولی چرا اسکالا ؟

توضیح این چرایی نسبت به گروه‌ها و شرکت‌ها متفاوت است؛ اما با این حال می‌توان دلایل زیر را به صورت اجماعی برای همه‌ی آن‌ها برشمرد:

- چابکی (Agility) و Productivty : با شرایط کنونی تجارت، سرعت در ارائه‌ی خدمات و توسعه‌ی آن از موارد غیر قابل چشم‌پوشی است؛ Scala با تکیه بر قابلیت‌های Functional و Syntax فوق‌العاده منعطف خود به عنوان زبان DSL Friendly مطرح می‌شود؛ زبان‌های DSL برای حل مشکلات خاص طراحی می‌شوند، به گونه‌ای که برای حل آن مشکل خلاصه ترین راه ممکن را ارائه میدهند ( مثل زبان R در پردازش اطلاعات ). زبان‌های DSL Firendly از هم مانند زبان‌های DSL، راه حل‌های خلاصه، سریع و مناسب را برای مشکل مورد نظر ارائه میدهند؛ Scala و Ruby از زبان‌های DSL Frinedly به حساب می‌آیند. اما متاستفانه Ruby در زمان اجرا سرعت خوبی ندارد.

‍‍‍‍‍```
// Read a file and print to Output

// Scala
val file  = scala.io.Source.fromFile(“filename”)
file.getLines foreach println

// Ruby
f = File.open(“filename”)
f.each_line do | line |
   puts line
end

// Java
InputStream in = InputStreamReader( new File(“filename”) );
Scanner file = new Scanner( in );
while( file.hasNextLine() ){
   System.out.println( file.getNextLine() );
}
```

- مقیاس‌پذیز (Scalablity)  و Performance : زبان Scala یک زبان Static است که پس از کامپایل به ByteCode های JVM تبدیل می‌شود. JVM از نظر سرعت هیچ کمبودی ندارد؛ بلاخص وقتی که JVM به واسطه‌ی ویژگی JIT ، به نهایت سرعت محاسباتی سخت‌افزار دست پیدا می‌کند. از طرفی دیگر Scala به واسطه‌ی قابلیت‌هایی که دارد، برنامه‌نویس را قادر می‌سازد تا به راحتی بتواند برنامه‌اش را مناسب با سخت‌افزار های MultiCore بنویسد؛ در این حالت برنامه از تمام منابع سیستم برای پردازش سریع‌تر استفاده میکند. از آنجایی که چارچوب/بستر Typesafe بر اساس معماری Reactive بنا شده است، Scalablity از ویژگی‌های اساسی آن است. Performance خوب در کنار قابلیت‌های Scalablity و همچنین productivity بالای Scala باعث می‌شود تا گروه برنامه‌نویسی با فراق خاطر روی حل مسأله و Bisuness تمرکز داشته باشد.

- بستر JVM و Java : همان‌طور که پیش اشاره‌ کردم کد‌های Scala به ByteCode های JVM تبدیل می‌شوند؛ در این تبدیل، عناصر زبان Scala به نزدیک‌ترین عناصر زبان Java ترجمه میشوند. این فرایند باعث نزدیکی بیشتر ۲ زبان به همدیگر میشود؛ این ویژگی باعث می‌شود که بتوان از این دو زبان در کنار هم استفاده کرد ؛ بر همین اساس به راحتی میتوان از Scala در ایجاد Servlet ها ، EJB ها و حتی در ترکیب با Spring استفاده کرد ( در حالی که برای Jython و ، JRuby و ... اینطور نیست )؛ تمام کتابخانه‌های نوشته شده به زبان Java در Scala قابل استفاده‌اند و این به معنی دسترسی به حجم بسیار زیادی از کتابخانه‌ها برای حل انواع مسائل است، که می‌تواند به کار توسعه‌ی نرم‌افزا سرعت بدهد. لازم به ذکر که کتابخانه‌های تولید شده توسط Scala هم در زبان Java قابل استفاده اند؛ پروژه‌های Play ، Akka و Finagle از این دسته هستند.

- ویژگی‌های فنی : Scala یک زبان Object-Orinted است که راهکارهای Functional ای را برای حل بهتر مسائل ارائه میکند ( بحث OO بودن یا Functional بودن Scala در این بخش نمیگنجد ). همچنین Scala دارای Type System قوی است که به برنامه‌نویس در کنترل نوع‌های داده‌ای و تست کد‌ها در زمان کامپایل کمک بسزایی میکند. Scala با تکیه بر همین ویژگی‌ها بستری مناسبی را برای تولید نرم‌افزارهای کاربردی و ابزار‌های تکنولوژیک ایجاد کرده است که Akka تنها یکی از نمونه‌های آن است. کتابخانه‌های Scalaz ، ScalaNLP ، Spark و … از ابزار‌های تولید شده بوسیله‌ی Scala هستند. از طرفی ویژگی‌های فنی بالا، برای برنامه‌نویسان که عموما به دنبال یادگیری و چالش‌ها جدید هستند، جذاب است و باعث رضایت شغلی بیشتری می‌شود.


### جامعه‌ی برنامه‌نویسان ( Community )، ابزار‌ها و پروژه‌ها

فعال‌ترین جامعه‌ی برنامه‌نویسان اسکالا در ایالات متحده و اروپا است (که خیلی طبیعی است)؛ و بیشترین نوآوری‌ها و اثر گذاری از جوامع یاد شده صورت می‌گیرد. پروژه‌های موجود در چارچوب/بستر Typesafe و پروژه‌های خارج از آن (  که بخشی از آن‌ها توسط Apache ، بخشی توسط گروه تازه تاسیس typelevel.org ، و … مدیریت و پشتیبانی می‌شوند ) از کیفیت بالایی برخودارند و عموما توسط چهره‌های سرشناس جامعه اسکالا مدیریت می‌شوند. 
چارچوب/بستر Typesafe ( که از پشتیبانی رسمی شرکت Typesafe سود‌می‌برد ) شامل پروژه‌های زیر است:

- کامپایلر اصلی اسکالا
- چارچوب Akka ( چارچوبی برای تسهیل تولید نرم‌افزارهای توزیع شده )
- چارچوب Play ( برای تولید برنامه‌های وب -  )
- شبه ORM به نامSlick : ابزاری برای تسهیل کار با پایگاه‌های داده با تعریفی مشابه ORM ها؛ این ابزار طبق تعریف جامعه‌ی برنامه‌نویسان اسکالا یک FRM – Functional Relation Map است.
- محیط توسعه‌یScala IDE : محیط توسعه (IDE ) ای برای اسکالا؛ این IDE مبتی بر Eclipse است.
- ابزار تحت مرورگرTypesafe Activator : یک ابزار مبتنی بر وب برای ایجاد انواع پرو‌‌ژه‌های کاربردی؛ با امکانات محیا شده در این ابزار تحت مرورگر شروع پروژه / تست و کامپایل / مشاهده‌ی کل و … تسهیل یافته و برای …. ؟!!؟؟!!
- ابزارSbt : یک ابزار ترمینالی برای کامپایل ، تست و تعیین … ؟!؟!

و اما ابزار‌های دیگر:
- کامپایلر‌‌های دیگر اسکالا ( کامپایلر‌/مفسر اسکالا به جاوا اسکریپت ، کامپایلر گروه typelevel.org و کامپایلر‌های تحقیقاتی دانشگاه‌ها )
- چارچوب Scalatra : یک میکرو وب فریمورک با الگو پذیری از Sinatra؛ سریع و مناسب برای کار‌های کوچک
- کتابخانه‌یScalaz : کتابخانه‌ای بی‌نظیر برای برای تسهیل برنامه‌نویسی با الگو‌های تابعی Functional
- چارچوب Spray : ابزاری مبتنی بر Akka برای ایجاد سرویس‌های RESTful
- چارچوب Finagle : ابزار/بستری برای پیاده‌سازی معماری SOA و ایجاد سرویس‌های کوچک برای کار با هم. این پروژه توسط Twitter ایجاد شده است
- کتابخانه‌یSpire : یک کتابخانه برای انجام محاسبات ریاضی و جبر با Syntax ای ساده و روان.
- ...

در پایان این بخش هم به چند پروژه‌ی کابردی‌ای که با اسکالا تولید شده‌اند اشاره‌میکنم:
- چارچوب پردازش داده‌یSpark : یکی ابزار‌های موفق BigData که به دلیل روش کاری/پیاده سازی محدودیت‌هایی را اعمال میکند، ولی سرعت بسیار بالایی دارد؛ همچنین می‌توان ترکیبی از Spark و Hadoop را برای برخی مسائل به کار بست.
- نرم‌افزار Kafka : یک ابزار توزیع پیام ( Message Passing ) به روش Publish-Subscribe است که سرعت بالایی دارد و همچنین از ویژگی‌های توزیع شدگی و مقیاس پذیری نیز سود میبرد.
- نرم‌افزار Apollo : یک ابزار توزیع پیام دیگر که استاندارد‌های AMQP 1.0 ، STOMP ، MQTT و OpenWire را پشتیبانی میکند؛ این پروژه نسل جدید ActiveMQ است و به دلیل مشابهت پروتکل AMQP 1.0 با JMS در پروژه‌های JavaEE هم قابل استفاده است.
- ...
نکته: پروژه‌های نام برده ( Spark ، Kafka و Apollo ) توسط بنیاد Apache پشتیبانی می‌شوند.

### و اما ایران ...
تعداد برنامه‌نویسان اسکالا در ایران زیاد نیست؛ و تقریباً می‌توان نیاز ۱۰ الی ۱۵ شرکت حرفه‌ای تولید نرم‌افزار با تیم‌های کوچک را برآورده کرد؛ البته نکته‌ی مثبتی که در این میان وجود دارد این است که نزدیک به ۶۰ درصد از این اشخاص، دارای تخصص و شناخت عمیقی از بستر هستند؛ یکی از حسن‌های آن این است که در کنار این متخصصین، آموزش می‌تواند سریع‌تر و بهتر اتفاق بیافتد. هرچند همین تعداد اندک هم تا کنون تأثیرات بسزایی داشتند. از پروژه‌های انجام شده در ایران میتوان به «سایت نمایشگاه بین‌الملی کتاب تهران» اشاره داشت که با بستر اسکالا انجام شده است.

### و اما نا گفته‌ها ...
«عیب می جمله بگفتی هنرش نیز بگو ...»
اینجا کار برعکس شده... مزایا گفته‌شده و کاستی ها باید مطرح بشود. شاید تأثیر گذارترین مورد، جامعه‌ی کاربری کوچک اسکالا در کشورهایی همچون ایران است که پیشتر در موردش توضیح داده شد؛ البته این کوچکی در مقایسه با PHP ، Java و ”Net.” است؛ اما در مقایسه با Ruby ، Erlang و زبان‌های مشابه که اخیراً مورد توجه قرار گرفته‌اند وضعیت مطلوبی دارد.
از مطالبی که در رابطه با اسکالا عموما مطرح می‌شود پیچیدگی زبان است که مانع یادگیری می‌شود! اسکالا زبان ساده‌ای، اما این سادگی به معنی آسانی نیست. از آنجایی که اسکالا ویژگی‌های زیادی را در کنار هم ارائه می‌دهد، تسلط بر تمام آن‌ها زمان‌بر است. تقریباً برنامه‌نویس می‌تواند در عرض دو هفته الی یک ماه به سطحی برسد که بتواند از اسکالا و چارچوب پلی ( Play ) برای ایجاد برنامه‌های وب استفاده کند، ولی این استفاده به معنی تخصص در آن زمینه نخواهد بود. مارتین اُدرسکی ( Martin Odersky ) خالق زبان اسکالا در مطلبی که وب سایت رسمی اسکالا منتشر شده، برنامه‌نویسان اسکالا را به 6 سطح تقسیم میکند که عملاً 3 سطح اولیه هیچ پیچیدگی ندارند و نامی که برای سطح سوم قائل است «Expert Application Programmer» است! آنچه که به عنوان پیچیدگی‌های زبانی مطرح است برای رسیدن به سطح Senior Developer ای مطرح می‌شود.
کامپایل شدن کد‌های اسکالا نسبت به جاوا و زبان‌های مشابه کامپایلی زمان بیشتری را میگیرد؛ برای کسانی که با زبان‌های کامپایلی همچون جاوا تجربه‌هایی دارند این موضوع خوشایند نیست. ویژگی‌های زبانی اسکالا باعث طولانی شدن زمان کامپایل می‌شوند. به طور مثال کامپایل Trait ها ، بهینه سازی‌های Tail Recursion و … از دلایل این هزینه‌ی زمانی هستند. برای حل این مشکل برخی گروه‌ها بعضی از امکانات زبان را غیرفعال می‌کنند، برخی هم استفاده از سرور کامپایل را پیشنهاد می‌دهند.
مشکل دیگری که تنها برنامه‌نویسانی که با جاوا سابقه‌ی کار دارند با آن روبرو می‌شوند، عدم وجود یک IDE تمام و کمال است؛ ویژگی‌های زبانی اسکالا پیچیدگی‌هایی را در  ایجاد Auto-Suggetion ها و Refactoring کامل برای IDE ها ایجاد کرده است.
جز مورد کوچکی‌ جامعه‌ی کاربری اسکالا در کشور‌های مشابه ایران، موارد دیگر مشکلاتی کلی‌ای نبودند؛ اما دو مورد فنی وجود دارد که علارغم اینکه در پروژه مشکلی را بوجود نمی‌آورند، ولی بار منفی‌ای در انتخاب اسکالا وارد می‌کنند:
اسکالا یک زبان برنامه نویسی رو به رشد است؛ برای گروه‌هایی که ثبات در ابزار برایشان امری حیاتی تلقی می‌شود، تغییرات در خود زبان ( هر چند مدیریت شده ) باعث آزردگی خاطرشان می‌شود؛ گروه‌ها و  اشخاصی که از حاضر به مهاجرت از Python 2.X به نسخه‌ی 3 نیستند، یا برنامه‌نویسانی جاوایی که ویژگی lambda در جاوا 8 را مضحک قلمداد می‌کنند، به احتمال خیلی زیاد با تغییراتی که در نسخه‌های minor یا major اسکالا ایجاد می‌شود، احساس خوبی نخواهند داشت ( به هیچ عنوان قصد توهین ندارم؛ هر برنامه‌نویسی با معیار‌های شخصی «ابزار کارآمد» را انتخاب می‌کنند. برخی طرفدار ثبات‌اند و برخی شیفته‌ی نوآوری‌ها  ). به عنوان یک نمونه از تغییرات می‌شود به منقضی شدن کتابخانه‌ی استاندارد scala.actor از نسخه‌ی 2.8 و جایگزین شدن Akka به جای آن اشاره داشت. این مشکل به همراه مشکلی مطرح خواهم کرد به‌ راحتی قابل حل هستند.
مشکل دومی که در نگاه اول باعث نگرانی می‌شود، عدم Binary Compatiblity است. یعنی اگر شما یک کتابخانه‌ی اسکالا را با نسخه‌ی 2.10 کامپایل کنید، نمی‌توانید فایل‌های باینری حاصل از کامپایل در پروژه‌ی دیگری با نسخه‌ی پایین‌تر یا بالاتر استفاده کنید ( مثلاً اسکالا 2.11 ) و شما نیاز دارید که همان پروژه را با نسخه‌ی فعلی ( 2.11 ) مجدداً کامپایل کنید. این کار به نظر زمان بر می‌آید، ولی شاید بد نباشد بدونید که گروه فنی خبرگذاری Guardian تنها در یک روز تمام سیستم‌های نرم‌افزاری شان را از اسکالا 2.7 به 2.8 بروز رسانی کردند ( با حذف تمام پیام‌های اخطار -Warning- ).

انتظار می‌رود که این دو مورد پایانی تأثیرات منفی را در کار گروه فنی ایجاد کند؛ همگام بودن و بروز‌رسانی اطلاعات و ابزار شاید برای همه دلپذیر نباشد. اما این مشکل با یک ابزار تولید و تست خوب اصلاً به چشم نمی‌آیند. SBT ابزاری که توسط آن شما نسخه‌ی اسکالا، نام و نسخه‌ی کتابخانه‌های استفاده شده را مشخص میکنید و اجرای تست نرم‌افزار ( تست هایی گروه فنی برای نرم‌افزار نوشت‌اند ) و و کامپایل و رفع مشکل نسخه‌های متفاوت را حل میکند. ابزاری مشابه npm در Node.Js یا Maven برای Java. امروزه استفاده از ابزارهای تولید و تست خودکار در بسیاری از فرایند‌های تبدیل به یک استاندارد شده‌اند.

### من طرف‌دار زبان اسکالا نیستم...
بله، در کل من طرفدار هیچ زبان و تکنولوژی‌ای نیستم؛ به قول معروف « با هیچ زبان برنامه‌نویسی ازدواج نکردم »! سعی من همیشه بر این بوده تا برحسب نیازم بهترین ابزار را برای کارم انتخاب و یا به دیگران معرفی کنم. امروز هم اسکالا را در کنار چارچوب‌های موجود برای آن، ابزار مناسبی برای تولید انواع نرم‌افزار می‌دانم. در مقاله‌ای هم که خواندید سعی کردم نکات مثبت و منفی را به طوری شایسته و در کنار هم ذکر کنم تا انتخاب یا عدم انتخاب به صورت آگاهانه و صحیح ممکن بشود. امیدوارم به این هدف رسیده باشم.

‍‍```
از مقایسه‌ی اسکالا و ... تا یگ حرف خودمونی

پوزش می‌خواهم که این حرف را میزنم، اما به شدت از مقایسه‌های سطحی و غیر فنی بیزارم... اگر بدون داشتن اطلاعات کافی می‌گویید «اسکالا پیچیده است »، باید عرض کنم پیچیدگی اسکالا از پیچیدگی ترکیب Decorator ها و MetaClass پایتون یا قابلیت‌های MetaPrograming ای که در Ruby و JavaScript و Clojure وجود دارند پیچیده‌تر نیست؛ اگر می‌خواهید بگویید که «JVM سریع نیست» یا «مصرف حافظه‌اش زیاد است» بهتره کمی در رابطه با Memory Model پایتون، روبی یا پی.اچ.پی  و تفاوت کامپایلر و مفسر و ویژگی Just-In-Time تحقیق کنید. قطعاً نظر‌تان عوض می‌شود؛ اگر می‌خواهید بگویید که …
فکر می‌کنم جامعه‌ی فنی IT ایران باید به میزانی از سواد و درک رسیده باشد که بدونه « هر گل یک بویی داره »! و هر ابزار یک کاربردی. من به شخصه دوست دارم با اسکالا کار کنم، اما  سعی میکنم با مطالعه، مزایای Go ، Erlang ، Python و … را بدانم و بتوانم برای مشتری احتمالی بهترین مشاوره را بدهم. بهترین ابزار برای انجام آن کار، و این یعنی رفتار حرفه‌ای!
```

Martin Odersky's note about Level of Scala-Developers: http://www.scala-lang.org/old/node/8610
About Gaurdian migiration: http://www.infoq.com/articles/guardian_scala
About Yammer migration **from** Scala:
- http://www.infoworld.com/t/java-programming/yammer-banks-scala-ends-moving-java-180803
- https://gist.github.com/anonymous/1406238

